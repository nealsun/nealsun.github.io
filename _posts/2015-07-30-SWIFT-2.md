---
layout:     post
title:      Swift 2
date:       2015-07-31 00:33:00
summary:    Swift集合了编程语言最新的研究成果和多年来开发苹果平台的经验。引入了命名参数，类型推断，模块化，arc等特性
categories: Swift2 iOS Apple Cocoa
---

### Modern Programming Language

​     何为modern，即modern language有哪些特点？苹果文档是这样描述的：

>Swift is the result of the latest research on programming languages, combined with decades of experience building Apple platforms. Named parameters brought forward from Objective-C are expressed in a clean syntax that makes APIs in Swift even easier to read and maintain. Inferred types make code cleaner and less prone to mistakes, while modules eliminate headers and provide namespaces. Memory is managed automatically, and you don’t even need to type semi-colons. All this modern thinking results in a language that is easy and fun to use.

Swift集合了编程语言最新的研究成果和多年来开发苹果平台的经验。引入了命名参数，类型推断，模块化，arc等特性；

以下是其他一些重要特性：

1. 闭包
2. 元组
3. 泛型
4. 快速简洁的迭代
5. 支持**方法**、**扩展**、**协议**的struct
6. 函数式编程
7. 原生的错误处理机制

Apple在iOS 9发布后，同时增加了Objective-c一些新语法（如数组支持类型声明），应该是为了整体向swift迁移做准备吧。

### Playground

​    Playground是随swift一同引入的一种交互式编程模式，它可以让你写代码的时候实时查看运行结果，同时playground的注释支持markdown语法，这使得playground能够方便的作为展示代码的工具，本文所有的例子也都会在playground上运行。

### 语法简介

学习语言惯例，从*hello， world！*开始，

``` swift
print("Hello, world!"); //Hello, world!
```

![helloworld](/images/helloworld.png)

playground上看到的效果就是这样的，左边是swift语句，右边是该语句执行的结果。

<span class="red">注意：</span>swift的字符串不需要像objc一样以`@`开头。



##### 变量声明

swift分别使用关键字`let`和`var`来声明常量和变量，变量类型的声明跟在名称后面用`：`分隔。 不过swift引入了类型推断，当编译器可以推断出变量的类型时，不需要显式的声明变量类型。

``` swift
let aConst = 70.0 //double，编译器根据字面量70.0推断类型是double
var aVar = 30 //int，编译器根据字面量30推断类型是int
let aDoubleConst: Double = 70 //double， 需要显式声明，因为赋了int的字面量，编译器会推断为整型
var aStringVar: String //string，需要显式声明，因为只声明了变量名，编译器缺少推断信息
```

更好玩的是swift支持使用unicode来声明变量，我们可以拿个emoji表情来声明更形象的变量名。

``` swift
let 🐷 = "pig"
let 🐶 = "dog"
```

格式化字符串也变得简单直观，通过`\()`把需要替换的变量包起来

``` swift
let name = "丁丁"
let height = 1.8
let weight = 77.0
let tall = "\(name)的身高是\(height)m,体重是\(weight)kg，那么他的BMI是\(weight/(height*height))"
```

声明数组和词典可以用字面量或者初始化方法

``` swift
var aArray = ["apple", "banana", "orange"]
aArray[1] = "peach"

var aDict = [
				"name": "jack",
                "class": "math",
            ]
aDict["name"] = "jim"

let emptyArray = [String]()
let emptyDictionary = [String: Float]()
```

swift的`Array`和`Dictionary`是有类型的，如果一个`Array`声明为一个`String`类型，那么就不能给他增加其他类型的变量，而objc的`NSArray`可以添加任何对象，swift为了兼容这一点引入了几个特殊类型，`AnyObject`和`Any`，使得`[AnyObject]`能添加任何对象。这样真的大丈夫？为了兼容损失了一丢丢的优雅？

另外swift的`Array`和`Dictionary`是没有mutable和immutable类型区分的，是否可变取决于声明时是`let`还是`var`。

实验遇到一个问题，感觉挺割裂的...

``` swift
var objcList = [] //类型推断是NSArray
var swiftList: [String] = [] //这样就是Array了
```

##### Optional

前面声明的变量都是不能设置为`nil`的，如果需要设置`nil`，需要在声明的时候在类型后面增加`?`标识符，他表示这个变量可能有值可能是`nil`。 Optinal在swift中是个重要的概念，后面专门写一篇来介绍。

``` swift
var aVar: String?
```



##### 控制流

`if`语句

``` swift
var condition = true
if condition {
	...
}
```

condition必须是布尔表达式，所以c或objc那种习惯非0非空的隐式转换的思维行不通了。

判断Optional是否为空的正确姿势是：使用`let`或者`var`声明常量赋值，如果Optional是空，那么进入`else`语句，否则Optional解开后赋值给声明的变量，且在语句中可以直接使用该变量。

``` swift
var optionalName: String? = "John Appleseed"
var greeting = "Hello!"
if let name = optionalName {
    greeting = "Hello, \(name)"
}
```

`for ... in ...`语句

`for  in `可以用来遍历数组和字典，如果你不关心遍历的值，可以用`_`代替。

``` swift
let aArray = [1, 2, 3, 4, 5, 6]
for num in aArray {
  print(num)
}

let aDict = ["1": 1, "2": 2, "3": 3]
for (key, value) in aDict {
  print("\(key) value is \(value)")
}
//当不关心value的值时用_代替
for (key, _) in aDict {
  print(key)
}
```

`...`和`..<`是`for in `迭代index的简化写法，`…`包括起始值和结束值，`..<`包括起始值但不包括结束值，直接看代码吧。

``` swift
//原来
for let i=0; i<10; i++ {
  ...
}

//现在
for i in 0..<10 {
  ...
}
```



`switch`变得强大的多，不限于整型值的比较，且比较的方式也变得更加丰富，但`switch`需要列出完整的`case`，如果没有完整列出那么`default`是必须的。所以在遍历枚举类型时，要么完整列出所有枚举值，要么必须加上`default`。

另外每一个`case`不需要添加`break`语句，因为swift的`switch`语句不会自动执行下一个case。如果需要多个case执行同一个语句，可以把多个判断写在同一个case中用**，**好分开。

``` swift
let vegetable = "red pepper"
switch vegetable {
case "celery":
    let vegetableComment = "Add some raisins and make ants on a log."
case "cucumber", "watercress":
    let vegetableComment = "That would make a good tea sandwich."
case let x where x.hasSuffix("pepper"):
    let vegetableComment = "Is it a spicy \(x)?"
default:
    let vegetableComment = "Everything tastes good in soup."
}
```

##### 函数和闭包

``` swift
func sayHello(name: String, day: String) -> String {
    return "Hello \(name), today is \(day)."
}
```

关键字`func`声明一个函数， 紧跟着函数名sayHello，函数名后`()`内是形参，参数名在前类型在后，和变量声明一样， `->`后面是函数返回类型，swift允许函数通过元组返回多个值 。

在swift里，函数是一等公民，所以函数可以作为返回值，作为函数参数，函数可以嵌套在函数里。

``` swift
//函数嵌套
func returnFifteen() -> Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()

//函数作为返回值
func makeIncrementer() -> (Int -> Int) {
    func addOne(number: Int) -> Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)

//函数作为参数
func hasAnyMatches(list: [Int], condition: Int -> Bool) -> Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -> Bool {
    return number < 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(numbers, lessThanTen)
```

闭包

函数是特殊的闭包。闭包是把声明时的上下文封装起来，即使调用时在不同的上下文。

闭包的语法

闭包使用`({})`包起来，使用关键字`in`分隔函数头和函数体，其中如果上下文语意明确可以忽略函数头中的变量名或返回值或全部。

如果函数体只有一行不需要显式`return`返回值，那句唯一的执行语句就会作为返回值。

闭包体中可以用参数序号来访问（`$0`, `$1`）

``` swift
//以下三种闭包声明，实现的功能相同
let mappedNumbers = numbers.map({
    (number: Int) -> Int in
    let result = 3 * number
    return result
})

let mappedNumbers = numbers.map({ number in 3 * number })

let mappedNumbers = numbers.map({ 3 * $0 })
```

##### 类和对象

``` swift
class Shape {
    var numberOfSides = 0
    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}
```

使用关键字`class`声明一个类，swift的对象没有统一的基类，Objc的对象都是继承与`NSObject`。

实例化一个对象很简单：

``` swift
var shape = Shape()
```

继承一个类：

``` swift
class NamedShape {
    var numberOfSides: Int = 0
    var name: String

    //初始化时必须给所有属性赋值，或者在属性声明时提供默认值
    init(name: String) {
        self.name = name
    }

    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}

class Square: NamedShape {
    var sideLength: Double

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }

    func area() ->  Double {
        return sideLength * sideLength
    }

    override func simpleDescription() -> String {
        return "A square with sides of length \(sideLength)."
    }
}
```

如上代码所示，子类覆盖父类必须用`override`关键字显式声明，否则会报错。这也体现了swift编译器的严谨，防止写代码时覆盖父类的方法。

计算型属性，可以有`get`和`set`方法，`set`的默认参数名就是`newValue`

``` swift
class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }

    var perimeter: Double {
        get {
            return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }

    override func simpleDescription() -> String {
        return "An equilateral triangle with sides of length \(sideLength)."
    }
}
```

计算型属性通`set`方法，可以在属性被设置前后增加代码控制这个设置过程。那么对于存储型属性，swift提供了`willSet`和`didSet`方法来控制设置过程。

``` swift
class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
```

##### 枚举和结构

swift大大增强了`Enum`和`Struct`的能力，使他们不仅仅只是一种简单的基本数据了。

首先枚举不仅仅局限于定义整型类型，还可以关联字符串，浮点数等，甚至枚举的每一个值都不需要和某个原始类型关联，他们本身就是代表一个值。同时swift的枚举类型还能添加自己的方法。

``` swift
//Rank这个Enum的原始值是Int。
//Int作为原始值，默认就会自增，可以省略为没个case赋原始值
enum Rank: Int {
    case Ace = 1
    case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten
    case Jack, Queen, King
    func simpleDescription() -> String {
        switch self {
        case .Ace:
            return "ace"
        case .Jack:
            return "jack"
        case .Queen:
            return "queen"
        case .King:
            return "king"
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.Ace
let aceRawValue = ace.rawValue //rowValue就是enum声明时没个枚举值后面的实际值，我们也可以直接用rowValue创建一个枚举
let aceFromRawValue = Rank(rowValue: 1) // 等价于 Rank.Ace

//Enum也可以没有枚举值。没有枚举值的时候，不需要声明枚举值的类型
enum Suit {
    case Spades, Hearts, Diamonds, Clubs
    func simpleDescription() -> String {
        switch self {
        case .Spades:
            return "spades"
        case .Hearts:
            return "hearts"
        case .Diamonds:
            return "diamonds"
        case .Clubs:
            return "clubs"
        }
    }
}
let hearts = Suit.Hearts
let heartsDescription = hearts.simpleDescription()
```

除了`rowValue`，`Enum`还可以有关联值，每个`Enum`的实例都有一样的原始值，但可以有不同的关联值，这时候可以如下定一个枚举类型

``` swift
enum ServerResponse {
    case Result(String, String)
    case Error(String)
}

let success = ServerResponse.Result("6:00 am", "8:09 pm")
let failure = ServerResponse.Error("Out of cheese.")

switch success {
case let .Result(sunrise, sunset):
    let serverResponse = "Sunrise is at \(sunrise) and sunset is at \(sunset)."
case let .Error(error):
    let serverResponse = "Failure...  \(error)"
}
```

在swift中，struct几乎和class有一样的能力，最大的一个不同就是struct是值传递，class是引用传递。

``` swift
struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -> String {
        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
    }
}
let threeOfSpades = Card(rank: .Three, suit: .Spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
```

##### 协议和扩展

协议和扩展在意义上和Objc类似，用`protocol`声明协议，`extention`声明扩展。类，枚举，结构体都能使用协议。使用协议就像继承类一样，名称后面加协议名称并用`:`分开，多个协议可用逗号分开。可以使用协议声明变量，这个变量只能访问这个协议声明的方法和属性。

``` swift
protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()   //mutating表示这个方法需要修改struct属性，类是可以省略的，因为类本来就是可以修改属性的。
}

class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription

struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    //结构体必须用mutating声明方法才能修改
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription

extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
}
```

##### 泛型

有了泛型，可以实现更加优雅的解决方案，增加了代码的灵活性，高效性，安全性，使代码更加简洁，语意更加明确。

可以在类，结构体，枚举，函数和方法中使用泛型。

泛型的语法是用一对尖括号`<>`把泛型名括起来，然后可以使用该名称来作为类型名使用。

``` swift
func repeat<Item>(item: Item, times: Int) -> [Item] {
    var result = [Item]()
    for i in 0..<times {
        result.append(item)
    }
    return result
}

enum OptionalValue<T> {
    case None
    case Some(T)
}
var possibleInteger: OptionalValue<Int> = .None
possibleInteger = .Some(100)
```

可以使用`where`来限制泛型类型，如遵守某种协议，或两个泛型是否是同一个类型等。在简单情况下，可以省略`where`。

``` swift
func anyCommonElements <T, U where T: SequenceType, U: SequenceType, T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element> (lhs: T, rhs: U) -> Bool {
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
    }
    return false
}
anyCommonElements([1, 2, 3], [3])
```

以上内容是看了[A Swift Tour](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/GuidedTour.html#//apple_ref/doc/uid/TP40014097-CH2-ID1)后做得笔记，只是一个简单的导引，可以一窥swift的全貌，并没有深入语言新特性，后面对于各个重要的知识点去看了[Language Guide](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/TheBasics.html#//apple_ref/doc/uid/TP40014097-CH5-ID309)​后再做详细记录。